# Chapter 1: Variables and Data Types - Your First Real Conversation with Python

Look, if you've programmed before, you know what a variable is. But Python? Python treats variables like that friend who never judges you for changing your mind.

## Variables: No Declarations, No Drama

In most languages, you declare before you use. You tell the compiler, "Hey, this is going to be an integer, get ready." Python doesn't care about that ceremony.

```python
x = 5
x = "now I'm a string"
x = [1, 2, 3]  # oh look, a list now
```

This just works. No declaration, no type annotation (unless you want them for clarity), no questions asked. Python figures it out. This is called **dynamic typing**, and it's both your best friend and occasionally, your worst enemy. More on that later.

## The Underscore: Python's Little Secret

Variables can't start with numbers. `2fast` is illegal. `fast2` is fine. But here's what Python does differently - the underscore isn't just allowed, it's actually meaningful:

```python
_private = "I'm internal, don't touch"
__very_private = "I'm REALLY internal"
_ = "I'm the result you just ignored"
```

That last one? In the Python REPL, `_` holds the last result. Handy when you forgot to save something.

## Data Types: The Usual Suspects with a Twist

You know integers, floats, strings, booleans. Python has them all. But let me tell you what's different.

### Integers: Unlimited Size

In C, your int overflows. In Java, your int overflows. In Python? Your integer just... grows.

```python
x = 99999999999999999999999999999999999999
y = x * x  # still works, no overflow
```

Python doesn't cap integers at 32 or 64 bits. It'll use as much memory as needed. Performance hit? Sure. Brain damage from overflow bugs? None.

### Strings: Immutable but Flexible

Strings are immutable. You can't change them in place. But Python gives you three ways to write them:

```python
s1 = 'single quotes'
s2 = "double quotes"
s3 = '''triple quotes
can span
multiple lines'''
```

All three are strings. Use single or double for short ones (your choice, be consistent). Use triple for multi-line strings or docstrings.

Here's the thing about immutability:

```python
name = "John"
name[0] = "D"  # ERROR! Can't modify strings
name = "D" + name[1:]  # This works - you're creating a NEW string
```

Every string operation creates a new string. Remember this when you're concatenating in loops. It matters.

### None: Python's Way of Saying "Nothing Here"

Other languages have `null`, `nil`, `undefined`. Python has `None`. It's an object, it's a singleton, and it's the default return value of functions that don't explicitly return anything.

```python
result = print("hello")  # prints "hello"
print(result)  # prints None
```

Test for it with `is`, not `==`:

```python
if x is None:  # Good
if x == None:  # Works, but not Pythonic
```

Why? Because `None` is a singleton. There's only one `None` object in memory. `is` checks identity, `==` checks value. For `None`, identity is what you want.

## Type Conversion: Explicit is Better than Implicit

Python won't automatically convert types for you in most cases. This is intentional.

```python
x = "5"
y = 3
z = x + y  # ERROR! Can't add string and int
```

You have to be explicit:

```python
z = int(x) + y  # 8
z = x + str(y)  # "53"
```

This seems annoying until it saves you from a bug where you accidentally concatenated instead of adding, or vice versa. Python makes you say what you mean.

## Quick Type Checking

Want to know what type something is?

```python
type(5)        # <class 'int'>
type("hello")  # <class 'str'>
type(None)     # <class 'NoneType'>

isinstance(5, int)  # True - better for checking types
```

Use `isinstance()` over `type()` for checking. It respects inheritance, which matters when you get into classes.

---

**What You Just Learned:**
- Variables need no declaration
- Integers don't overflow
- Strings are immutable
- `None` is Python's null, check it with `is`
- Type conversions are explicit
- Underscores in variable names have meaning

Next up: we'll talk about making decisions with `if`, `elif`, and `else`. Because knowing how to store data means nothing if you can't decide what to do with it.